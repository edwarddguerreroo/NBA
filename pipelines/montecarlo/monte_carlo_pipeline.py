"""
Pipeline Principal de Simulación Monte Carlo NBA
==============================================

Pipeline completo que integra todos los componentes del sistema Monte Carlo
para generar simulaciones coherentes y probabilidades de apuestas deportivas.
"""

import sys
import os
from pathlib import Path
import logging
import pandas as pd
import numpy as np
from datetime import datetime
import json
from typing import Dict, List, Optional, Any

# Agregar el directorio raíz al path
sys.path.append(str(Path(__file__).parent.parent.parent))

from src.preprocessing.data_loader import NBADataLoader
from src.models.montecarlo import MonteCarloEngine, ProbabilityCalculator
from src.models.montecarlo.simulator import NBAGameSimulator
from config.logging_config import configure_model_logging
from src.models.montecarlo.correlations import NBACorrelationMatrix
from src.models.montecarlo.config import MASTER_CONFIG, get_target_players, is_target_player, get_target_player_line

# Configurar logging
logger = configure_model_logging("montecarlo_pipeline")


class MonteCarloNBAPipeline:
    """Pipeline principal del sistema Monte Carlo NBA con máxima precisión"""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.config = MASTER_CONFIG
        self.target_date = "4/24/2025"
        
        # Cargar datos
        self._load_data()
        
        # Inicializar componentes con configuración optimizada
        self._initialize_components()
        
        self.logger.info("Pipeline Monte Carlo NBA inicializado con configuración optimizada")

    def _load_data(self):
        """Carga y prepara los datos NBA"""
        loader = NBADataLoader(
            game_data_path='data/players.csv',
            biometrics_path='data/height.csv',
            teams_path='data/teams.csv'
        )
        
        # Cargar datos principales
        merged_data, teams_data = loader.load_data()
        
        # Separar datasets
        self.players_df = merged_data
        self.teams_df = teams_data
        self.height_df = pd.read_csv('data/height.csv')
        
        # Compilar datos históricos para el motor
        self.historical_data = {
            'players': self.players_df,
            'teams': self.teams_df,
            'height': self.height_df
        }
        
        # Estadísticas del dataset
        total_records = len(self.players_df)
        unique_players = self.players_df['Player'].nunique()
        
        # Identificar TODOS los jugadores para análisis completo
        self.all_players = self.players_df['Player'].unique().tolist()
        self.target_players = get_target_players()  # Solo para líneas especiales
        target_players_in_data = [p for p in self.target_players if p in self.all_players]
        
        self.logger.info(f"Datos cargados: {total_records:,} registros de {unique_players} jugadores")
        self.logger.info(f"TODOS los jugadores disponibles: {len(self.all_players)}")
        self.logger.info(f"Jugadores TARGET con líneas especiales: {len(target_players_in_data)}/{len(self.target_players)}")
        self.logger.info(f"Targets disponibles: {', '.join(target_players_in_data[:5])}{'...' if len(target_players_in_data) > 5 else ''}")
        self.logger.info(f"Sistema configurado para analizar TODOS los jugadores del partido")

    def _initialize_components(self):
        """Inicializa componentes con configuración optimizada"""
        
        # Verificar tipos de datos antes de inicializar componentes
        self.logger.info(f"Tipo de players_df: {type(self.players_df)}")
        self.logger.info(f"Tipo de teams_df: {type(self.teams_df)}")
        
        if isinstance(self.players_df, pd.DataFrame):
            self.logger.info(f"players_df shape: {self.players_df.shape}")
        if isinstance(self.teams_df, pd.DataFrame):
            self.logger.info(f"teams_df shape: {self.teams_df.shape}")
        
        # MATRIZ DE CORRELACIONES MEJORADA
        self.correlation_matrix = NBACorrelationMatrix(
            self.players_df, 
            self.teams_df
        )
        self.logger.info("Matriz de correlaciones NBA MEJORADA inicializada")
        
        # MOTOR MONTE CARLO REVOLUCIONARIO MEJORADO
        self.monte_carlo_engine = MonteCarloEngine(
            self.correlation_matrix,
            self.historical_data
        )
        
        # MOTOR MEJORADO CON INTEGRACIÓN DE MODELOS ESPECIALIZADOS
        try:
            # Intentar usar el motor mejorado con integración
            from src.models.montecarlo.enhanced_engine import EnhancedMonteCarloEngine
            self.enhanced_engine = EnhancedMonteCarloEngine(
                self.players_df, 
                self.teams_df
            )
            
            # SIMULADOR MEJORADO CON MOTOR AVANZADO
            self.enhanced_simulator = NBAGameSimulator(
                self.enhanced_engine,
                num_simulations=20000  # Más simulaciones con motor mejorado
            )
            
            self.use_enhanced_mode = True
            self.logger.info("🚀 Motor MEJORADO y Simulador AVANZADO activados")
            
        except Exception as e:
            self.logger.warning(f"No se pudo cargar motor mejorado: {e}")
            self.use_enhanced_mode = False
        
        # SIMULADOR ESTÁNDAR (fallback)
        num_simulations = self.config['simulation']['num_simulations']
        self.game_simulator = NBAGameSimulator(
            self.monte_carlo_engine,
            num_simulations=num_simulations
        )
        
        # CALCULADOR DE PROBABILIDADES OPTIMIZADO
        self.probability_calculator = ProbabilityCalculator()

    def simulate_daily_games(self, date: str) -> dict:
        """
        Simula todos los partidos de un día específico con máxima precisión
        
        Args:
            date: Fecha en formato 'MM/DD/YYYY'
        """
        self.logger.info(f"Iniciando simulación diaria para {date}")
        
        # IDENTIFICAR PARTIDOS DEL DÍA
        daily_games = self._get_daily_games(date)
        
        if not daily_games:
            self.logger.warning(f"No se encontraron partidos para {date}")
            return {
                'date': date,
                'total_games': 0,
                'games': {},
                'error': 'No se encontraron partidos'
            }
        
        # SIMULAR CADA PARTIDO CON ANÁLISIS COMPLETO
        simulation_results = {}
        successful_simulations = 0
        failed_simulations = 0
        
        for game_info in daily_games:
            home_team = game_info['home_team']
            away_team = game_info['away_team']
            game_key = f"{away_team}_vs_{home_team}"
            
            try:
                # SIMULACIÓN CON MOTOR MEJORADO SI ESTÁ DISPONIBLE
                if hasattr(self, 'use_enhanced_mode') and self.use_enhanced_mode and hasattr(self, 'enhanced_simulator'):
                    # Usar motor mejorado (funciona completamente)
                    game_result = self.enhanced_simulator.simulate_game(
                        home_team=home_team,
                        away_team=away_team,
                        date=date
                    )
                    self.logger.info(f"🎯 Simulación MEJORADA completada para {game_key}")
                else:
                    # SIMULACIÓN ESTÁNDAR
                    game_result = self.game_simulator.simulate_game(
                        home_team=home_team,
                        away_team=away_team,
                        date=date
                    )
                
                if 'error' not in game_result:
                    # ANÁLISIS DE APUESTAS AVANZADO
                    betting_analysis = self._calculate_betting_probabilities(game_result)
                    
                    # COMPILAR RESULTADO COMPLETO
                    simulation_results[game_key] = {
                        'game_simulation': game_result,
                        'betting_analysis': betting_analysis,
                        'confidence_score': self._calculate_confidence_score(game_result),
                        'key_insights': self._generate_key_insights(game_result, home_team, away_team)
                    }
                    
                    # GUARDAR RESULTADOS DEL PARTIDO INDIVIDUAL
                    self._save_game_results(game_key, simulation_results[game_key], date)
                    
                    successful_simulations += 1
                    
                else:
                    simulation_results[game_key] = {'error': game_result['error']}
                    failed_simulations += 1
                    
            except Exception as e:
                self.logger.error(f"Error simulando {game_key}: {str(e)}")
                simulation_results[game_key] = {'error': str(e)}
                failed_simulations += 1
        
        # COMPILAR RESUMEN DIARIO
        daily_summary = {
            'total_games': len(daily_games),
            'successful_simulations': successful_simulations,
            'failed_simulations': failed_simulations,
            'success_rate': successful_simulations / len(daily_games) if daily_games else 0,
            'avg_confidence': self._calculate_avg_confidence(simulation_results),
            'high_confidence_games': self._count_high_confidence_games(simulation_results)
        }
        
        # CREAR RESULTADOS DIARIOS COMPLETOS
        daily_results = {
            'date': date,
            'total_games': len(daily_games),
            'games': simulation_results,
            'daily_summary': daily_summary,
            'players_analysis': self._analyze_target_players(simulation_results),
            'system_info': {
                'simulations_per_game': self.config['simulation']['num_simulations'],
                'correlation_version': '2.0.0',
                'confidence_threshold': self.config['validation']['validation_metrics']['accuracy_threshold'],
                'all_players_analysis': True,
                'timestamp': datetime.now().isoformat()
            }
        }
        
        # GUARDAR RESUMEN DIARIO COMPLETO
        self._save_daily_summary(daily_results)
        
        return daily_results

    def _get_daily_games(self, date: str) -> list:
        """Obtiene los partidos únicos para una fecha específica"""
        
        # Verificar que teams_df sea un DataFrame
        if not isinstance(self.teams_df, pd.DataFrame):
            self.logger.error(f"teams_df no es un DataFrame, es: {type(self.teams_df)}")
            return []
        
        # Verificar que teams_df tenga la columna Date
        if 'Date' not in self.teams_df.columns:
            self.logger.error(f"Columna 'Date' no encontrada en teams_df. Columnas disponibles: {list(self.teams_df.columns)}")
            return []
        
        # Buscar partidos en el dataset de equipos
        date_games = self.teams_df[self.teams_df['Date'] == date]
        
        if date_games.empty:
            return []
        
        # Identificar partidos únicos (evitar duplicados home/away)
        unique_games = {}
        
        for _, game in date_games.iterrows():
            team = game['Team']
            opponent = game['Opp']
            is_away = game['Away'] == '@'
            
            # Crear clave única para el partido
            if is_away:
                # Equipo visitante
                game_key = f"{team}@{opponent}"
                home_team = opponent
                away_team = team
            else:
                # Equipo local
                game_key = f"{opponent}@{team}"
                home_team = team
                away_team = opponent
            
            # Asegurar formato consistente (visitante@local)
            sorted_key = f"{away_team}@{home_team}"
            
            if sorted_key not in unique_games:
                unique_games[sorted_key] = {
                    'home_team': home_team,
                    'away_team': away_team,
                    'date': date
                }
        
        games_list = list(unique_games.values())
        self.logger.info(f"Encontrados {len(games_list)} partidos únicos para {date}")
        
        return games_list

    def _calculate_confidence_score(self, game_result: dict) -> float:
        """Calcula puntuación de confianza para una simulación"""
        if 'error' in game_result:
            return 0.0
        
        confidence_factors = []
        
        # Factor 1: Número de simulaciones exitosas
        simulations_run = game_result.get('game_info', {}).get('simulations_run', 0)
        target_simulations = self.config['simulation']['num_simulations']
        sim_factor = simulations_run / target_simulations
        confidence_factors.append(sim_factor)
        
        # Factor 2: Estabilidad de la predicción (basada en desviación estándar)
        win_prob = game_result.get('win_probabilities', {})
        home_win = win_prob.get('home_win', 0.5)
        certainty = abs(home_win - 0.5) * 2  # 0-1, donde 1 es más cierto
        confidence_factors.append(certainty)
        
        # Factor 3: Calidad de los datos de jugadores
        model_reliability = game_result.get('confidence_metrics', {}).get('model_reliability', 0.5)
        confidence_factors.append(model_reliability)
        
        # Factor 4: Consistencia de resultados (basada en percentiles)
        score_predictions = game_result.get('score_predictions', {})
        if score_predictions:
            home_std = score_predictions.get('home_score', {}).get('std', 20)
            away_std = score_predictions.get('away_score', {}).get('std', 20)
            consistency = 1 / (1 + (home_std + away_std) / 30)  # Normalizado
            confidence_factors.append(consistency)
        
        # Calcular puntuación final (promedio ponderado)
        if confidence_factors:
            weights = [0.3, 0.3, 0.2, 0.2]  # Pesos para cada factor
            confidence_score = sum(f * w for f, w in zip(confidence_factors, weights[:len(confidence_factors)]))
        else:
            confidence_score = 0.5
        
        return max(0.0, min(1.0, confidence_score))

    def _generate_key_insights(self, game_result: dict, home_team: str, away_team: str) -> list:
        """Genera insights clave basados en los resultados de simulación"""
        insights = []
        
        if 'error' in game_result:
            return ['Error en simulación: análisis no disponible']
        
        # Insight 1: Predicción principal
        win_prob = game_result.get('win_probabilities', {})
        home_win = win_prob.get('home_win', 0.5)
        
        if home_win > 0.65:
            insights.append(f"{home_team} tiene ventaja clara en casa ({home_win:.1%})")
        elif home_win < 0.35:
            insights.append(f"{away_team} favorito como visitante ({1-home_win:.1%})")
        else:
            insights.append(f"Partido muy cerrado ({max(home_win, 1-home_win):.1%} vs {min(home_win, 1-home_win):.1%})")
        
        # Insight 2: Características del juego
        game_chars = game_result.get('game_characteristics', {})
        total_points = game_chars.get('total_points_avg', 0)
        
        if total_points > 230:
            insights.append(f"Se espera partido de muchos puntos (~{total_points:.0f} totales)")
        elif total_points < 210:
            insights.append(f"Se espera juego defensivo (~{total_points:.0f} puntos totales)")
        
        # Insight 3: Competitividad
        close_games_pct = game_chars.get('close_games_pct', 0)
        if close_games_pct > 0.4:
            insights.append(f"Alta probabilidad de final cerrado ({close_games_pct:.1%} de simulaciones)")
        
        # Insight 4: Confianza del modelo
        confidence = game_result.get('confidence_metrics', {}).get('prediction_confidence', 0.5)
        if confidence > 0.8:
            insights.append("Predicción de alta confianza")
        elif confidence < 0.6:
            insights.append("Predicción con incertidumbre moderada")
        
        return insights

    def _calculate_avg_confidence(self, results: dict) -> float:
        """Calcula confianza promedio de todas las simulaciones"""
        confidences = []
        
        for game_result in results.values():
            if 'confidence_score' in game_result:
                confidences.append(game_result['confidence_score'])
        
        return np.mean(confidences) if confidences else 0.0

    def _count_high_confidence_games(self, results: dict) -> int:
        """Cuenta juegos con alta confianza (>75%)"""
        high_confidence_threshold = 0.75
        count = 0
        
        for game_result in results.values():
            if game_result.get('confidence_score', 0) > high_confidence_threshold:
                count += 1
        
        return count

    def _analyze_target_players(self, simulation_results: dict) -> dict:
        """
        Analiza las predicciones para TODOS los jugadores que participan en los partidos
        incluyendo targets con líneas reales y jugadores regulares con líneas dinámicas
        """
        players_analysis = {
            'players_analyzed': [],
            'target_players': [],
            'regular_players': [],
            'betting_recommendations': {},
            'high_confidence_bets': [],
            'summary': {
                'total_players_found': 0,
                'total_targets_found': 0,
                'recommended_bets': 0,
                'avg_confidence': 0.0
            }
        }
        
        total_confidence = 0
        confidence_count = 0
        
        for game_key, game_data in simulation_results.items():
            if 'error' in game_data:
                continue
                
            # Analizar jugadores en el juego
            game_simulation = game_data.get('game_simulation', {})
            
            # Obtener simulaciones de jugadores directamente
            player_simulations = game_simulation.get('player_simulations', {})
            
            for team_type in ['home', 'away']:
                team_players = player_simulations.get(team_type, {})
                
                for player_name, player_simulations_data in team_players.items():
                    # Agregar a la lista de jugadores analizados
                    players_analysis['players_analyzed'].append(player_name)
                    
                    # Clasificar como target o regular
                    if is_target_player(player_name):
                        players_analysis['target_players'].append(player_name)
                    else:
                        players_analysis['regular_players'].append(player_name)
                    
                    # Convertir simulaciones a estadísticas promedio para análisis
                    if isinstance(player_simulations_data, list) and len(player_simulations_data) > 0:
                        # Calcular promedios de las simulaciones
                        avg_stats = {}
                        for stat in ['PTS', 'TRB', 'AST', 'STL', 'BLK', '3P']:
                            stat_values = [sim.get(stat, 0) for sim in player_simulations_data if isinstance(sim, dict)]
                            if stat_values:
                                avg_stats[stat] = sum(stat_values) / len(stat_values)
                        
                        # Analizar contra líneas de apuesta (reales para TARGET, dinámicas para TODOS los demás)
                        player_recommendations = self._analyze_player_betting_lines(
                            player_name, avg_stats, game_key
                        )
                        
                        if player_recommendations:
                            players_analysis['betting_recommendations'][f"{player_name}_{game_key}"] = player_recommendations
                            
                            # Contar recomendaciones de alta confianza
                            for rec in player_recommendations:
                                # Confianza mínima diferente para TARGET vs regulares
                                min_confidence = 0.75 if is_target_player(player_name) else 0.70
                                
                                if rec.get('confidence', 0) >= min_confidence:
                                    players_analysis['high_confidence_bets'].append({
                                        'player': player_name,
                                        'game': game_key,
                                        'bet_type': rec['stat'],
                                        'line': rec['line'],
                                        'prediction': rec['prediction'],
                                        'recommendation': rec['recommendation'],
                                        'confidence': rec['confidence'],
                                        'is_target_player': is_target_player(player_name),
                                        'line_type': 'real' if is_target_player(player_name) else 'dynamic'
                                    })
                                    total_confidence += rec['confidence']
                                    confidence_count += 1
        
        # Resumen final
        players_analysis['summary'] = {
            'total_players_found': len(set(players_analysis['players_analyzed'])),
            'total_targets_found': len(set(players_analysis['target_players'])),
            'total_regular_players': len(set(players_analysis['regular_players'])),
            'recommended_bets': len(players_analysis['high_confidence_bets']),
            'avg_confidence': total_confidence / confidence_count if confidence_count > 0 else 0.0
        }
        
        return players_analysis

    def _analyze_player_betting_lines(self, player_name: str, player_stats: dict, game_key: str) -> list:
        """
        Analiza las estadísticas de un jugador contra líneas de apuesta
        Usa líneas reales para targets y líneas dinámicas para otros jugadores
        """
        recommendations = []
        
        # Estadísticas principales para analizar
        key_stats = ['PTS', 'TRB', 'AST', 'STL', 'BLK', '3P']
        
        for stat in key_stats:
            if stat in player_stats and player_stats[stat] > 0:
                predicted_value = player_stats[stat]
                
                # Obtener línea de apuesta
                if is_target_player(player_name):
                    # Para targets: usar línea real de las casas
                    betting_line = get_target_player_line(player_name, stat)
                else:
                    # Para jugadores regulares: generar línea dinámica basada en predicción
                    betting_line = self._generate_dynamic_betting_line(predicted_value, stat)
                
                if betting_line > 0:  # Solo si hay línea disponible
                    # Calcular diferencia y confianza
                    difference = predicted_value - betting_line
                    confidence = self._calculate_betting_confidence(difference, stat)
                    
                    # Generar recomendación si hay suficiente confianza
                    min_confidence = 0.75 if is_target_player(player_name) else 0.70  # Menos estricto para regulares
                    
                    if confidence >= min_confidence:
                        recommendation = "OVER" if difference > 0 else "UNDER"
                        
                        recommendations.append({
                            'stat': stat,
                            'line': betting_line,
                            'prediction': round(predicted_value, 1),
                            'difference': round(difference, 1),
                            'recommendation': recommendation,
                            'confidence': round(confidence, 3),
                            'edge': round(abs(difference) / betting_line * 100, 1) if betting_line > 0 else 0,
                            'line_type': 'real' if is_target_player(player_name) else 'dynamic'
                        })
        
        return recommendations

    def _generate_dynamic_betting_line(self, predicted_value: float, stat: str) -> float:
        """
        Genera líneas de apuesta dinámicas para CUALQUIER jugador que no esté en TARGET_PLAYER_LINES
        Esto permite apostar en todos los 300+ jugadores activos de la NBA, no solo los 16 TARGET
        Basado en la predicción del modelo con ajustes conservadores típicos de sportsbooks
        """
        # Factores de ajuste para diferentes estadísticas
        adjustment_factors = {
            'PTS': 0.90,   # Línea 10% por debajo de predicción
            'TRB': 0.85,   # Línea 15% por debajo
            'AST': 0.80,   # Línea 20% por debajo
            'STL': 0.75,   # Línea 25% por debajo
            'BLK': 0.75,   # Línea 25% por debajo
            '3P': 0.80     # Línea 20% por debajo
        }
        
        # Líneas mínimas por estadística
        min_lines = {
            'PTS': 0.5,
            'TRB': 0.5,
            'AST': 0.5,
            'STL': 0.5,
            'BLK': 0.5,
            '3P': 0.5
        }
        
        adjustment = adjustment_factors.get(stat, 0.80)
        min_line = min_lines.get(stat, 0.5)
        
        # Calcular línea ajustada
        dynamic_line = predicted_value * adjustment
        
        # Redondear a 0.5 más cercano (formato típico de casas de apuestas)
        dynamic_line = round(dynamic_line * 2) / 2
        
        # Aplicar línea mínima
        return max(dynamic_line, min_line)

    def _calculate_betting_confidence(self, difference: float, stat: str) -> float:
        """
        Calcula la confianza de una apuesta basada en la diferencia predicción vs línea
        """
        # Umbrales por estadística (basados en variabilidad típica)
        confidence_thresholds = {
            'PTS': {'high': 3.0, 'medium': 1.5},
            'TRB': {'high': 2.0, 'medium': 1.0},
            'AST': {'high': 1.5, 'medium': 0.8},
            'STL': {'high': 0.5, 'medium': 0.3},
            'BLK': {'high': 0.5, 'medium': 0.3}
        }
        
        if stat not in confidence_thresholds:
            return 0.5  # Confianza neutral
        
        thresholds = confidence_thresholds[stat]
        abs_diff = abs(difference)
        
        if abs_diff >= thresholds['high']:
            return 0.85  # Alta confianza
        elif abs_diff >= thresholds['medium']:
            return 0.75  # Confianza media-alta
        else:
            # Confianza proporcional
            return 0.5 + (abs_diff / thresholds['medium']) * 0.25

    def initialize_simulator(self) -> None:
        """Inicializa el simulador de partidos."""
        logger.info("Inicializando simulador de partidos...")
        
        self.game_simulator = NBAGameSimulator(
            data_loader=self.data_loader,
            n_simulations=self.n_simulations,
            random_state=self.random_state
        )
        
        logger.info("Simulador inicializado correctamente")
    
    def simulate_single_game(self,
                           home_team: str,
                           away_team: str,
                           home_players: List[str],
                           away_players: List[str],
                           game_context: Optional[Dict[str, Any]] = None,
                           custom_lines: Optional[Dict[str, List[float]]] = None,
                           n_simulations: Optional[int] = None) -> Dict[str, Any]:
        """
        Simula un partido individual completo.
        
        Args:
            home_team: Equipo local
            away_team: Equipo visitante
            home_players: Lista de jugadores locales
            away_players: Lista de jugadores visitantes
            game_context: Contexto adicional del juego
            custom_lines: Líneas personalizadas de apuestas
            n_simulations: Número de simulaciones (usa default si None)
            
        Returns:
            Diccionario completo con simulaciones y probabilidades
        """
        if self.game_simulator is None:
            self.initialize_simulator()
        
        if n_simulations is None:
            n_simulations = self.n_simulations
        
        logger.info(f"Iniciando simulación: {away_team} @ {home_team}")
        
        # Ejecutar simulación del partido
        simulation_results = self.game_simulator.simulate_game(
            home_team=home_team,
            away_team=away_team,
            home_players=home_players,
            away_players=away_players,
            game_context=game_context,
            n_simulations=n_simulations
        )
        
        # Calcular probabilidades de apuestas
        probability_report = self._calculate_betting_probabilities(
            simulation_results, custom_lines
        )
        
        # Compilar resultado completo
        complete_result = {
            'simulation_data': simulation_results,
            'betting_analysis': probability_report,
            'execution_info': {
                'timestamp': datetime.now().isoformat(),
                'n_simulations': n_simulations,
                'random_state': self.random_state
            }
        }
        
        # Guardar en cache
        game_key = f"{away_team}_at_{home_team}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        self.simulation_results[game_key] = complete_result
        
        logger.info(f"Simulación completada: {game_key}")
        
        return complete_result
    
    def simulate_multiple_games(self,
                              games_config: List[Dict[str, Any]],
                              parallel: bool = False) -> Dict[str, Dict[str, Any]]:
        """
        Simula múltiples partidos.
        
        Args:
            games_config: Lista de configuraciones de partidos
            parallel: Si ejecutar en paralelo (futuro)
            
        Returns:
            Diccionario con resultados de todos los partidos
        """
        logger.info(f"Simulando {len(games_config)} partidos...")
        
        all_results = {}
        
        for i, game_config in enumerate(games_config):
            try:
                logger.info(f"Procesando partido {i+1}/{len(games_config)}")
                
                result = self.simulate_single_game(**game_config)
                
                game_key = f"game_{i+1}_{game_config['away_team']}_at_{game_config['home_team']}"
                all_results[game_key] = result
                
            except Exception as e:
                logger.error(f"Error simulando partido {i+1}: {e}")
                continue
        
        logger.info(f"Simulación múltiple completada: {len(all_results)} partidos exitosos")
        
        return all_results
    
    def _calculate_betting_probabilities(self,
                                       simulation_results: Dict[str, Any],
                                       custom_lines: Optional[Dict[str, List[float]]] = None) -> Dict[str, Any]:
        """Calcula probabilidades de apuestas basadas en simulaciones."""
        logger.debug("Calculando probabilidades de apuestas...")
        
        # Extraer datos de simulación
        player_sims = simulation_results.get('player_simulations', {})
        team_sims = simulation_results.get('team_simulations', {})
        game_results = simulation_results.get('game_results', [])
        game_info = simulation_results.get('game_info', {})
        
        # Convertir listas de diccionarios a DataFrames si es necesario
        if isinstance(team_sims.get('home'), list):
            team_sims['home'] = pd.DataFrame(team_sims['home'])
        if isinstance(team_sims.get('away'), list):
            team_sims['away'] = pd.DataFrame(team_sims['away'])
        if isinstance(game_results, list):
            game_results = pd.DataFrame(game_results)
        
        # Calcular probabilidades por jugador
        player_probabilities = {}
        
        # Jugadores locales
        for player, simulations in player_sims.get('home', {}).items():
            # Convertir lista de diccionarios a DataFrame si es necesario
            if isinstance(simulations, list):
                simulations = pd.DataFrame(simulations)
                
            player_probs = self.probability_calculator.calculate_player_probabilities(
                simulations=simulations,
                player_name=player,
                custom_lines=custom_lines
            )
            player_probabilities[f"{player}_home"] = player_probs
        
        # Jugadores visitantes
        for player, simulations in player_sims.get('away', {}).items():
            # Convertir lista de diccionarios a DataFrame si es necesario
            if isinstance(simulations, list):
                simulations = pd.DataFrame(simulations)
                
            player_probs = self.probability_calculator.calculate_player_probabilities(
                simulations=simulations,
                player_name=player,
                custom_lines=custom_lines
            )
            player_probabilities[f"{player}_away"] = player_probs
        
        # Calcular probabilidades por equipo
        team_probabilities = {}
        
        home_team_probs = self.probability_calculator.calculate_team_probabilities(
            team_simulations=team_sims['home'],
            team_name=game_info['home_team'],
            custom_lines=custom_lines
        )
        team_probabilities['home'] = home_team_probs
        
        away_team_probs = self.probability_calculator.calculate_team_probabilities(
            team_simulations=team_sims['away'],
            team_name=game_info['away_team'],
            custom_lines=custom_lines
        )
        team_probabilities['away'] = away_team_probs
        
        # Calcular probabilidades del partido
        game_probabilities = self.probability_calculator.calculate_game_probabilities(
            game_results=game_results,
            home_team=game_info['home_team'],
            away_team=game_info['away_team']
        )
        
        # Generar reporte completo de apuestas
        betting_report = self.probability_calculator.generate_betting_report(
            player_probs=player_probabilities,
            team_probs=team_probabilities,
            game_probs=game_probabilities
        )
        
        return betting_report
    
    def generate_comprehensive_report(self,
                                    simulation_results: Dict[str, Any],
                                    output_dir: str = "results/montecarlo") -> str:
        """
        Genera reporte completo de simulación.
        
        Args:
            simulation_results: Resultados de simulación
            output_dir: Directorio de salida
            
        Returns:
            Ruta del archivo generado
        """
        os.makedirs(output_dir, exist_ok=True)
        
        # Generar nombre de archivo único
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        report_filename = f"montecarlo_report_{timestamp}.json"
        report_path = os.path.join(output_dir, report_filename)
        
        # Preparar reporte completo
        comprehensive_report = {
            'metadata': {
                'generated_at': datetime.now().isoformat(),
                'pipeline_version': '1.0.0',
                'n_simulations': self.n_simulations,
                'random_state': self.random_state
            },
            'simulation_summary': self._generate_simulation_summary(simulation_results),
            'detailed_results': simulation_results,
            'statistical_analysis': self._generate_statistical_analysis(simulation_results),
            'betting_insights': self._extract_betting_insights(simulation_results)
        }
        
        # Guardar reporte
        with open(report_path, 'w') as f:
            json.dump(comprehensive_report, f, indent=2, default=str)
        
        logger.info(f"Reporte completo guardado: {report_path}")
        
        return report_path
    
    def _generate_simulation_summary(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """Genera resumen de la simulación."""
        # Buscar datos en diferentes formatos
        sim_data = results.get('simulation_data', results)
        
        if sim_data:
            # Obtener información de manera segura
            game_results = sim_data.get('game_results', [])
            team_sims = sim_data.get('team_simulations', {})
            
            # Convertir a DataFrame si es necesario
            if isinstance(game_results, list):
                game_results = pd.DataFrame(game_results)
                
            home_team_sims = team_sims.get('home', [])
            if isinstance(home_team_sims, list):
                home_team_sims = pd.DataFrame(home_team_sims)
            
            summary = {
                'game_info': sim_data.get('game_info', {}),
                'players_simulated': {
                    'home': len(sim_data.get('player_simulations', {}).get('home', {})),
                    'away': len(sim_data.get('player_simulations', {}).get('away', {}))
                },
                'simulation_stats': {
                    'total_scenarios': len(game_results) if isinstance(game_results, pd.DataFrame) else 0,
                    'variables_tracked': len(home_team_sims.columns) if isinstance(home_team_sims, pd.DataFrame) and not home_team_sims.empty else 0
                }
            }
        else:
            summary = {'error': 'Formato de resultados no reconocido'}
        
        return summary
    
    def _generate_statistical_analysis(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """Genera análisis estadístico avanzado."""
        analysis = {}
        
        # Buscar datos en diferentes formatos
        sim_data = results.get('simulation_data', results)
        
        # Análisis de distribuciones
        if 'game_results' in sim_data:
            game_results = sim_data['game_results']
            
            # Convertir a DataFrame si es necesario
            if isinstance(game_results, list):
                game_results = pd.DataFrame(game_results)
            
            if isinstance(game_results, pd.DataFrame) and not game_results.empty:
                analysis['game_distributions'] = {
                    'total_points': {
                        'mean': float(game_results['total_points'].mean()) if 'total_points' in game_results.columns else 0,
                        'std': float(game_results['total_points'].std()) if 'total_points' in game_results.columns else 0,
                        'skewness': float(game_results['total_points'].skew()) if 'total_points' in game_results.columns else 0,
                        'kurtosis': float(game_results['total_points'].kurtosis()) if 'total_points' in game_results.columns else 0
                    },
                    'point_differential': {
                        'mean': float(game_results['point_differential'].mean()) if 'point_differential' in game_results.columns else 0,
                        'std': float(game_results['point_differential'].std()) if 'point_differential' in game_results.columns else 0,
                        'skewness': float(game_results['point_differential'].skew()) if 'point_differential' in game_results.columns else 0
                    }
                }
        
        # Análisis de correlaciones
        if 'team_simulations' in sim_data:
            home_sims = sim_data['team_simulations']['home']
            away_sims = sim_data['team_simulations']['away']
            
            # Convertir a DataFrame si es necesario
            if isinstance(home_sims, list):
                home_sims = pd.DataFrame(home_sims)
            if isinstance(away_sims, list):
                away_sims = pd.DataFrame(away_sims)
            
            # Correlaciones principales
            main_stats = ['PTS', 'TRB', 'AST']
            
            if isinstance(home_sims, pd.DataFrame) and isinstance(away_sims, pd.DataFrame):
                available_stats = [stat for stat in main_stats if stat in home_sims.columns]
                
                if len(available_stats) > 1:
                    home_corr = home_sims[available_stats].corr()
                    away_corr = away_sims[available_stats].corr()
                    
                    analysis['team_correlations'] = {
                        'home': home_corr.to_dict(),
                        'away': away_corr.to_dict()
                    }
        
        return analysis
    
    def _extract_betting_insights(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """Extrae insights clave para apuestas."""
        insights = {}
        
        if 'betting_analysis' in results:
            betting_data = results['betting_analysis']
            
            # Extraer recomendaciones de alta confianza
            recommendations = betting_data.get('recommendations', [])
            high_confidence = [rec for rec in recommendations if rec.get('confidence') == 'Alta']
            
            insights['high_confidence_bets'] = high_confidence
            
            # Extraer probabilidades extremas (muy altas o muy bajas)
            extreme_probs = []
            
            # Revisar probabilidades de jugadores
            player_analysis = betting_data.get('player_analysis', {})
            for player, probs in player_analysis.items():
                if isinstance(probs, dict) and 'special_events' in probs:
                    for event, prob in probs['special_events'].items():
                        if prob > 0.8 or prob < 0.2:
                            extreme_probs.append({
                                'player': player,
                                'event': event,
                                'probability': prob,
                                'type': 'extreme_high' if prob > 0.8 else 'extreme_low'
                            })
            
            insights['extreme_probabilities'] = extreme_probs
            
            # Resumen de oportunidades
            insights['opportunity_summary'] = {
                'total_high_confidence_bets': len(high_confidence),
                'total_extreme_probabilities': len(extreme_probs),
                'recommended_focus': 'player_props' if len(extreme_probs) > 3 else 'game_totals'
            }
        
        return insights
    
    def export_results_to_csv(self,
                            simulation_results: Dict[str, Any],
                            output_dir: str = "results/montecarlo") -> List[str]:
        """
        Exporta resultados a archivos CSV para análisis externo.
        
        Args:
            simulation_results: Resultados de simulación
            output_dir: Directorio de salida
            
        Returns:
            Lista de archivos CSV generados
        """
        os.makedirs(output_dir, exist_ok=True)
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        exported_files = []
        
        if 'simulation_data' in simulation_results:
            sim_data = simulation_results['simulation_data']
            
            # Exportar resultados del partido
            if 'game_results' in sim_data:
                game_file = os.path.join(output_dir, f"game_results_{timestamp}.csv")
                sim_data['game_results'].to_csv(game_file, index=False)
                exported_files.append(game_file)
            
            # Exportar simulaciones de equipos
            if 'team_simulations' in sim_data:
                for team_type, team_data in sim_data['team_simulations'].items():
                    team_file = os.path.join(output_dir, f"team_{team_type}_{timestamp}.csv")
                    team_data.to_csv(team_file, index=False)
                    exported_files.append(team_file)
            
            # Exportar simulaciones de jugadores (muestra)
            if 'player_simulations' in sim_data:
                for team_type, players in sim_data['player_simulations'].items():
                    for player, player_data in players.items():
                        # Solo exportar primeros 1000 registros para evitar archivos muy grandes
                        sample_data = player_data.head(1000)
                        player_file = os.path.join(
                            output_dir, 
                            f"player_{player.replace(' ', '_')}_{team_type}_{timestamp}.csv"
                        )
                        sample_data.to_csv(player_file, index=False)
                        exported_files.append(player_file)
        
        logger.info(f"Exportados {len(exported_files)} archivos CSV")
        
        return exported_files
    
    def _save_game_results(self, game_key: str, game_data: dict, date: str) -> None:
        """
        Guarda resultados de un partido individual en archivos organizados
        """
        try:
            # Crear estructura de directorios organizados por fecha
            date_formatted = date.replace('/', '-')
            output_dir = f"results/montecarlo/{date_formatted}/games"
            os.makedirs(output_dir, exist_ok=True)
            
            timestamp = datetime.now().strftime("%H%M%S")
            
            # 1. GUARDAR ANÁLISIS COMPLETO DEL PARTIDO (JSON)
            game_analysis_file = os.path.join(output_dir, f"{game_key}_analysis_{timestamp}.json")
            
            # Preparar datos para guardar (con métricas del modelo)
            analysis_data = {
                'metadata': {
                    'game_key': game_key,
                    'date': date,
                    'timestamp': datetime.now().isoformat(),
                    'simulations_count': self.config['simulation']['num_simulations']
                },
                'game_analysis': game_data,
                'model_metrics': self._extract_model_metrics(game_data),
                'performance_stats': self._calculate_performance_stats(game_data)
            }
            
            with open(game_analysis_file, 'w', encoding='utf-8') as f:
                json.dump(analysis_data, f, indent=2, default=str, ensure_ascii=False)
            
            # 2. GUARDAR DATOS DE SIMULACIÓN RAW (CSV) 
            self._save_simulation_data_csv(game_data, output_dir, game_key, timestamp)
            
            # 3. GUARDAR RECOMENDACIONES DE APUESTAS (CSV)
            self._save_betting_recommendations_csv(game_data, output_dir, game_key, timestamp)
            
            self.logger.info(f"Resultados de {game_key} guardados en {output_dir}")
            
        except Exception as e:
            self.logger.error(f"Error guardando resultados de {game_key}: {str(e)}")

    def _save_daily_summary(self, daily_results: dict) -> None:
        """
        Guarda el resumen diario completo con métricas agregadas
        """
        try:
            date = daily_results['date']
            date_formatted = date.replace('/', '-')
            output_dir = f"results/montecarlo/{date_formatted}"
            os.makedirs(output_dir, exist_ok=True)
            
            timestamp = datetime.now().strftime("%H%M%S")
            
            # 1. RESUMEN EJECUTIVO DIARIO
            summary_file = os.path.join(output_dir, f"daily_summary_{timestamp}.json")
            
            enhanced_summary = {
                'executive_summary': daily_results,
                'model_performance': self._calculate_daily_model_performance(daily_results),
                'betting_insights': self._generate_daily_betting_insights(daily_results),
                'system_diagnostics': self._get_system_diagnostics()
            }
            
            with open(summary_file, 'w', encoding='utf-8') as f:
                json.dump(enhanced_summary, f, indent=2, default=str, ensure_ascii=False)
            
            # 2. MÉTRICAS AGREGADAS CSV
            self._save_daily_metrics_csv(daily_results, output_dir, timestamp)
            
            # 3. RESUMEN DE RECOMENDACIONES
            self._save_daily_recommendations_summary(daily_results, output_dir, timestamp)
            
            self.logger.info(f"Resumen diario guardado en {output_dir}")
            
        except Exception as e:
            self.logger.error(f"Error guardando resumen diario: {str(e)}")

    def _extract_model_metrics(self, game_data: dict) -> dict:
        """Extrae métricas específicas del modelo para evaluación"""
        metrics = {
            'confidence_score': game_data.get('confidence_score', 0.0),
            'prediction_accuracy_est': 0.0,
            'model_stability': 0.0,
            'data_quality_score': 0.0
        }
        
        # Calcular estabilidad del modelo basada en variabilidad de predicciones
        if 'game_simulation' in game_data:
            sim_data = game_data['game_simulation']
            
            # Analizar consistencia de predicciones de puntuación
            score_preds = sim_data.get('score_predictions', {})
            if score_preds:
                home_std = score_preds.get('home_score', {}).get('std', 20)
                away_std = score_preds.get('away_score', {}).get('std', 20)
                
                # Menor desviación estándar = mayor estabilidad
                metrics['model_stability'] = 1 / (1 + (home_std + away_std) / 30)
            
            # Evaluar calidad de datos basada en completitud
            game_info = sim_data.get('game_info', {})
            total_players = game_info.get('total_players_simulated', 0)
            expected_players = 24  # Aproximadamente 12 por equipo
            
            metrics['data_quality_score'] = min(1.0, total_players / expected_players)
        
        # Estimar precisión basada en confianza y estabilidad
        metrics['prediction_accuracy_est'] = (
            metrics['confidence_score'] * 0.6 + 
            metrics['model_stability'] * 0.4
        )
        
        return metrics

    def _calculate_performance_stats(self, game_data: dict) -> dict:
        """Calcula estadísticas de rendimiento para mejora continua"""
        stats = {
            'execution_time_est': 0.0,
            'memory_usage_est': 0.0,
            'convergence_rate': 0.0,
            'error_rate': 0.0
        }
        
        # Estimar tiempo de ejecución basado en número de simulaciones
        num_sims = self.config['simulation']['num_simulations']
        stats['execution_time_est'] = num_sims * 0.001  # Estimación
        
        # Calcular tasa de convergencia basada en estabilidad
        if 'confidence_score' in game_data:
            stats['convergence_rate'] = game_data['confidence_score']
        
        # Revisar errores en la simulación
        if 'error' in game_data:
            stats['error_rate'] = 1.0
        else:
            stats['error_rate'] = 0.0
        
        return stats

    def _save_simulation_data_csv(self, game_data: dict, output_dir: str, game_key: str, timestamp: str) -> None:
        """Guarda datos raw de simulación en CSV para análisis posterior"""
        try:
            if 'game_simulation' in game_data:
                sim_data = game_data['game_simulation']
                
                # Guardar resultados de partidos simulados
                if 'simulation_data' in sim_data and 'game_results' in sim_data['simulation_data']:
                    game_results = sim_data['simulation_data']['game_results']
                    
                    if isinstance(game_results, list):
                        df = pd.DataFrame(game_results)
                    else:
                        df = game_results
                    
                    if not df.empty:
                        csv_file = os.path.join(output_dir, f"{game_key}_simulations_{timestamp}.csv")
                        df.to_csv(csv_file, index=False)
                        
        except Exception as e:
            self.logger.error(f"Error guardando CSV de simulaciones: {str(e)}")

    def _save_betting_recommendations_csv(self, game_data: dict, output_dir: str, game_key: str, timestamp: str) -> None:
        """Guarda recomendaciones de apuestas en formato CSV"""
        try:
            if 'betting_analysis' in game_data:
                betting = game_data['betting_analysis']
                recommendations = betting.get('recommendations', [])
                
                if recommendations:
                    df = pd.DataFrame(recommendations)
                    csv_file = os.path.join(output_dir, f"{game_key}_betting_recommendations_{timestamp}.csv")
                    df.to_csv(csv_file, index=False)
                    
        except Exception as e:
            self.logger.error(f"Error guardando CSV de recomendaciones: {str(e)}")

    def _calculate_daily_model_performance(self, daily_results: dict) -> dict:
        """Calcula métricas de rendimiento del modelo a nivel diario"""
        performance = {
            'overall_confidence': daily_results['daily_summary'].get('avg_confidence', 0.0),
            'success_rate': daily_results['daily_summary'].get('success_rate', 0.0),
            'high_confidence_ratio': 0.0,
            'prediction_distribution': {},
            'model_reliability_score': 0.0
        }
        
        # Calcular ratio de alta confianza
        total_games = daily_results['daily_summary']['total_games']
        high_conf_games = daily_results['daily_summary']['high_confidence_games']
        
        if total_games > 0:
            performance['high_confidence_ratio'] = high_conf_games / total_games
        
        # Calcular score de confiabilidad del modelo
        performance['model_reliability_score'] = (
            performance['overall_confidence'] * 0.5 +
            performance['success_rate'] * 0.3 +
            performance['high_confidence_ratio'] * 0.2
        )
        
        return performance

    def _generate_daily_betting_insights(self, daily_results: dict) -> dict:
        """Genera insights de apuestas a nivel diario"""
        insights = {
            'total_opportunities': 0,
            'high_value_bets': [],
            'risk_assessment': 'medium',
            'recommended_bankroll_allocation': {}
        }
        
        # Contar oportunidades totales
        total_recs = 0
        for game_key, game_data in daily_results['games'].items():
            if 'betting_analysis' in game_data:
                recs = game_data['betting_analysis'].get('recommendations', [])
                total_recs += len(recs)
        
        insights['total_opportunities'] = total_recs
        
        # Evaluar riesgo basado en confianza promedio
        avg_conf = daily_results['daily_summary'].get('avg_confidence', 0.0)
        if avg_conf > 0.8:
            insights['risk_assessment'] = 'low'
        elif avg_conf < 0.6:
            insights['risk_assessment'] = 'high'
        
        return insights

    def _get_system_diagnostics(self) -> dict:
        """Obtiene diagnósticos del sistema para monitoreo"""
        return {
            'pipeline_version': '1.0.0',
            'simulation_engine': 'Monte Carlo v2.0',
            'data_loader_status': 'operational',
            'last_update': datetime.now().isoformat(),
            'memory_usage': 'normal',
            'performance_status': 'optimal'
        }

    def _save_daily_metrics_csv(self, daily_results: dict, output_dir: str, timestamp: str) -> None:
        """Guarda métricas diarias en CSV para tracking histórico"""
        try:
            metrics_data = []
            
            for game_key, game_data in daily_results['games'].items():
                if 'error' not in game_data:
                    metrics_data.append({
                        'game_key': game_key,
                        'date': daily_results['date'],
                        'confidence_score': game_data.get('confidence_score', 0.0),
                        'betting_recommendations': len(game_data.get('betting_analysis', {}).get('recommendations', [])),
                        'model_stability': game_data.get('confidence_score', 0.0),  # Placeholder
                        'execution_status': 'success'
                    })
                else:
                    metrics_data.append({
                        'game_key': game_key,
                        'date': daily_results['date'],
                        'confidence_score': 0.0,
                        'betting_recommendations': 0,
                        'model_stability': 0.0,
                        'execution_status': 'error'
                    })
            
            if metrics_data:
                df = pd.DataFrame(metrics_data)
                csv_file = os.path.join(output_dir, f"daily_metrics_{timestamp}.csv")
                df.to_csv(csv_file, index=False)
                
        except Exception as e:
            self.logger.error(f"Error guardando métricas diarias: {str(e)}")

    def _save_daily_recommendations_summary(self, daily_results: dict, output_dir: str, timestamp: str) -> None:
        """Guarda resumen consolidado de todas las recomendaciones del día"""
        try:
            all_recommendations = []
            
            for game_key, game_data in daily_results['games'].items():
                if 'betting_analysis' in game_data:
                    recs = game_data['betting_analysis'].get('recommendations', [])
                    for rec in recs:
                        rec['game_key'] = game_key
                        rec['date'] = daily_results['date']
                        all_recommendations.append(rec)
            
            if all_recommendations:
                df = pd.DataFrame(all_recommendations)
                csv_file = os.path.join(output_dir, f"all_recommendations_{timestamp}.csv")
                df.to_csv(csv_file, index=False)
                
        except Exception as e:
            self.logger.error(f"Error guardando resumen de recomendaciones: {str(e)}")

    def get_pipeline_status(self) -> Dict[str, Any]:
        """Obtiene el estado actual del pipeline."""
        return {
            'initialized': hasattr(self, 'game_simulator') and self.game_simulator is not None,
            'data_loaded': hasattr(self, 'players_df') and self.players_df is not None,
            'components_ready': all([
                hasattr(self, 'correlation_matrix'),
                hasattr(self, 'monte_carlo_engine'),
                hasattr(self, 'game_simulator'),
                hasattr(self, 'probability_calculator')
            ]),
            'config_loaded': hasattr(self, 'config') and self.config is not None,
            'target_players_count': len(get_target_players()),
            'simulations_per_game': self.config['simulation']['num_simulations'] if hasattr(self, 'config') else 0
        }


def main():
    """
    Función principal para demostrar el uso del pipeline Monte Carlo NBA
    """
    logger.info("Iniciando pipeline Monte Carlo NBA...")
    
    # Crear pipeline
    pipeline = MonteCarloNBAPipeline()
    
    # Probar simulación diaria
    logger.info("Probando simulación diaria...")
    daily_results = pipeline.simulate_daily_games('4/24/2025')
    
    if daily_results and 'error' not in daily_results:
        print(f"\n=== SIMULACIÓN DIARIA COMPLETADA ===")
        print(f"Fecha: {daily_results['date']}")
        print(f"Total partidos: {daily_results['total_games']}")
        print(f"Simulaciones exitosas: {daily_results['daily_summary']['successful_simulations']}")
        print(f"Simulaciones fallidas: {daily_results['daily_summary']['failed_simulations']}")
        print(f"Tasa de éxito: {daily_results['daily_summary']['success_rate']:.1%}")
        print(f"Confianza promedio: {daily_results['daily_summary']['avg_confidence']:.1%}")
        
        # Mostrar información de archivos guardados
        date_formatted = daily_results['date'].replace('/', '-')
        print(f"\n=== ARCHIVOS GUARDADOS ===")
        print(f"Directorio principal: results/montecarlo/{date_formatted}/")
        print(f"- Resumen diario: daily_summary_HHMMSS.json")
        print(f"- Métricas diarias: daily_metrics_HHMMSS.csv")
        print(f"- Todas las recomendaciones: all_recommendations_HHMMSS.csv")
        print(f"- Análisis por partido: games/[PARTIDO]_analysis_HHMMSS.json")
        print(f"- Simulaciones raw: games/[PARTIDO]_simulations_HHMMSS.csv")
        print(f"- Recomendaciones por partido: games/[PARTIDO]_betting_recommendations_HHMMSS.csv")
        
        # Mostrar algunos resultados
        print(f"\n=== RESUMEN DE PARTIDOS ===")
        for game_key, game_result in list(daily_results['games'].items())[:3]:
            if 'error' not in game_result:
                betting = game_result['betting_analysis']['game_overview']
                home_win = betting['win_probabilities']['home_win']
                away_win = betting['win_probabilities']['away_win']
                confidence = game_result.get('confidence_score', 0.0)
                recommendations = len(game_result['betting_analysis'].get('recommendations', []))
                
                print(f"\n{game_key}:")
                print(f"  - Probabilidades: Local {home_win:.1%} vs Visitante {away_win:.1%}")
                print(f"  - Confianza del modelo: {confidence:.1%}")
                print(f"  - Recomendaciones de apuestas: {recommendations}")
        
        # Mostrar análisis de jugadores
        players_analysis = daily_results.get('players_analysis', {})
        summary = players_analysis.get('summary', {})
        
        print(f"\n=== ANÁLISIS DE JUGADORES ===")
        print(f"Total jugadores analizados: {summary.get('total_players_found', 0)}")
        print(f"Jugadores TARGET encontrados: {summary.get('total_targets_found', 0)}")
        print(f"Recomendaciones de apuestas generadas: {summary.get('recommended_bets', 0)}")
        print(f"Confianza promedio en apuestas: {summary.get('avg_confidence', 0.0):.1%}")
        
    else:
        error_msg = daily_results.get('error', 'Error desconocido') if daily_results else 'No se obtuvieron resultados'
        print(f"Error en simulación: {error_msg}")
    
    logger.info("Pipeline completado exitosamente")


if __name__ == "__main__":
    main() 